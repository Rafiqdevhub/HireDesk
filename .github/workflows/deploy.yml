name: Manual Deployment Pipeline

# ============================================================================
# DEPLOYMENT STRATEGY: Manual Control with Rollback Safety
# ============================================================================
# This workflow demonstrates operational thinking by:
# 1. Requiring manual approval before deployment (workflow_dispatch)
# 2. Managing deployment risk through staged rollouts
# 3. Providing rollback mechanisms
# 4. Validating deployments before full cutover
# 5. Maintaining deployment history and auditability
#
# Why Manual?
# - Production deployments require human judgment
# - Allows for verification of changes in staging
# - Provides control over timing (maintenance windows)
# - Enables coordination with stakeholders
# ============================================================================

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment for deployment"
        required: true
        type: choice
        options:
          - staging
          - production
      image_tag:
        description: "Docker image tag to deploy (e.g., v1.0.0, latest, commit-sha)"
        required: true
        type: string
      enable_rollback:
        description: "Keep previous container for quick rollback"
        required: false
        type: boolean
        default: true
      run_health_checks:
        description: "Run health checks before switching traffic"
        required: false
        type: boolean
        default: true

env:
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/hiredesk-ui
  CONTAINER_NAME: hiredesk-ui-${{ github.event.inputs.environment }}

jobs:
  # ==========================================================================
  # Pre-deployment Validation
  # ==========================================================================
  validate:
    name: Pre-Deployment Validation
    runs-on: ubuntu-latest
    outputs:
      deployment_id: ${{ steps.generate_id.outputs.id }}
      image_exists: ${{ steps.check_image.outputs.exists }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate deployment ID
        id: generate_id
        run: |
          DEPLOY_ID="deploy-$(date +%Y%m%d-%H%M%S)-${{ github.run_number }}"
          echo "id=$DEPLOY_ID" >> $GITHUB_OUTPUT
          echo "üÜî Deployment ID: $DEPLOY_ID"

      - name: Validate inputs
        run: |
          echo "üîç Validating deployment inputs..."
          echo "Environment: ${{ github.event.inputs.environment }}"
          echo "Image Tag: ${{ github.event.inputs.image_tag }}"
          echo "Rollback Enabled: ${{ github.event.inputs.enable_rollback }}"
          echo "Health Checks: ${{ github.event.inputs.run_health_checks }}"

          # Validate image tag format
          if [[ ! "${{ github.event.inputs.image_tag }}" =~ ^[a-zA-Z0-9._-]+$ ]]; then
            echo "‚ùå Invalid image tag format"
            exit 1
          fi

      - name: Check if Docker image exists
        id: check_image
        run: |
          echo "üîé Checking if image exists in registry..."

          # Login to container registry
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.DOCKER_REGISTRY }} -u ${{ github.actor }} --password-stdin

          # Check if image exists
          if docker manifest inspect ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.event.inputs.image_tag }} > /dev/null 2>&1; then
            echo "‚úÖ Image found: ${{ env.IMAGE_NAME }}:${{ github.event.inputs.image_tag }}"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Image not found: ${{ env.IMAGE_NAME }}:${{ github.event.inputs.image_tag }}"
            echo "exists=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Create deployment record
        run: |
          echo "üìù Creating deployment record..."
          cat > deployment-manifest.json <<EOF
          {
            "deployment_id": "${{ steps.generate_id.outputs.id }}",
            "environment": "${{ github.event.inputs.environment }}",
            "image_tag": "${{ github.event.inputs.image_tag }}",
            "triggered_by": "${{ github.actor }}",
            "timestamp": "$(date -Iseconds)",
            "commit_sha": "${{ github.sha }}",
            "rollback_enabled": ${{ github.event.inputs.enable_rollback }},
            "health_checks_enabled": ${{ github.event.inputs.run_health_checks }}
          }
          EOF
          cat deployment-manifest.json

      - name: Upload deployment manifest
        uses: actions/upload-artifact@v4
        with:
          name: deployment-manifest
          path: deployment-manifest.json
          retention-days: 90

  # ==========================================================================
  # Deployment to Target Environment
  # ==========================================================================
  deploy:
    name: Deploy to ${{ github.event.inputs.environment }}
    runs-on: ubuntu-latest
    needs: validate
    environment:
      name: ${{ github.event.inputs.environment }}
      url: ${{ steps.deployment.outputs.url }}

    steps:
      - name: Download deployment manifest
        uses: actions/download-artifact@v4
        with:
          name: deployment-manifest

      - name: Display deployment info
        run: |
          echo "üì¶ Deployment Information"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          cat deployment-manifest.json | jq '.'
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

      - name: Setup SSH connection to server
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DEPLOYMENT_SSH_KEY }}

      - name: Backup current container (if rollback enabled)
        if: github.event.inputs.enable_rollback == 'true'
        run: |
          echo "üíæ Creating backup of current container..."

          ssh -o StrictHostKeyChecking=no ${{ secrets.DEPLOYMENT_USER }}@${{ secrets.DEPLOYMENT_HOST }} << 'ENDSSH'
            set -e
            
            # Check if container exists and is running
            if docker ps -a --format '{{.Names}}' | grep -q "^${{ env.CONTAINER_NAME }}$"; then
              echo "‚úÖ Found existing container: ${{ env.CONTAINER_NAME }}"
              
              # Stop the container gracefully
              echo "üõë Stopping container..."
              docker stop ${{ env.CONTAINER_NAME }} --time=30 || true
              
              # Rename to backup
              BACKUP_NAME="${{ env.CONTAINER_NAME }}-backup-$(date +%Y%m%d-%H%M%S)"
              echo "üì¶ Renaming to: $BACKUP_NAME"
              docker rename ${{ env.CONTAINER_NAME }} $BACKUP_NAME
              
              echo "‚úÖ Backup created successfully"
              echo "BACKUP_CONTAINER=$BACKUP_NAME" >> deployment.env
            else
              echo "‚ÑπÔ∏è  No existing container to backup"
            fi
          ENDSSH

      - name: Pull new Docker image
        run: |
          echo "‚¨áÔ∏è  Pulling Docker image..."

          ssh -o StrictHostKeyChecking=no ${{ secrets.DEPLOYMENT_USER }}@${{ secrets.DEPLOYMENT_HOST }} << 'ENDSSH'
            set -e
            
            # Login to container registry
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.DOCKER_REGISTRY }} -u ${{ github.actor }} --password-stdin
            
            # Pull the image
            IMAGE_FULL_NAME="${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.event.inputs.image_tag }}"
            echo "üì• Pulling: $IMAGE_FULL_NAME"
            docker pull $IMAGE_FULL_NAME
            
            # Verify image
            docker images | grep "${{ env.IMAGE_NAME }}"
            
            echo "‚úÖ Image pulled successfully"
          ENDSSH

      - name: Stop old container
        run: |
          echo "üõë Stopping old container (if exists)..."

          ssh -o StrictHostKeyChecking=no ${{ secrets.DEPLOYMENT_USER }}@${{ secrets.DEPLOYMENT_HOST }} << 'ENDSSH'
            set -e
            
            # Stop and remove existing container if not backed up
            if docker ps -a --format '{{.Names}}' | grep -q "^${{ env.CONTAINER_NAME }}$"; then
              echo "Found container: ${{ env.CONTAINER_NAME }}"
              docker stop ${{ env.CONTAINER_NAME }} --time=30 || true
              docker rm ${{ env.CONTAINER_NAME }} || true
              echo "‚úÖ Old container removed"
            else
              echo "‚ÑπÔ∏è  No existing container to stop"
            fi
          ENDSSH

      - name: Load environment variables
        id: load_env
        run: |
          echo "üîê Loading environment-specific configuration..."

          # Set environment-specific variables
          if [[ "${{ github.event.inputs.environment }}" == "production" ]]; then
            echo "PORT=3000" >> $GITHUB_ENV
            echo "HOST_PORT=80" >> $GITHUB_ENV
            echo "NODE_ENV=production" >> $GITHUB_ENV
          else
            echo "PORT=3000" >> $GITHUB_ENV
            echo "HOST_PORT=3001" >> $GITHUB_ENV
            echo "NODE_ENV=staging" >> $GITHUB_ENV
          fi

      - name: Run new container
        id: deployment
        run: |
          echo "üöÄ Starting new container..."

          ssh -o StrictHostKeyChecking=no ${{ secrets.DEPLOYMENT_USER }}@${{ secrets.DEPLOYMENT_HOST }} << 'ENDSSH'
            set -e
            
            # Prepare environment file
            cat > /tmp/hiredesk-${{ github.event.inputs.environment }}.env <<EOF
          NODE_ENV=${{ env.NODE_ENV }}
          PORT=${{ env.PORT }}
          HOST=0.0.0.0
          VITE_API_BASE_URL=${{ secrets.VITE_API_BASE_URL }}
          VITE_APP_NAME=HireDesk
          VITE_APP_ENV=${{ github.event.inputs.environment }}
          DEPLOYMENT_ID=${{ needs.validate.outputs.deployment_id }}
          EOF
            
            # Run new container with injected environment variables
            docker run -d \
              --name ${{ env.CONTAINER_NAME }} \
              --env-file /tmp/hiredesk-${{ github.event.inputs.environment }}.env \
              -p ${{ env.HOST_PORT }}:${{ env.PORT }} \
              --restart unless-stopped \
              --health-cmd="curl -f http://localhost:${{ env.PORT }} || exit 1" \
              --health-interval=30s \
              --health-timeout=10s \
              --health-retries=3 \
              --health-start-period=40s \
              --log-driver json-file \
              --log-opt max-size=10m \
              --log-opt max-file=3 \
              ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.event.inputs.image_tag }}
            
            echo "‚úÖ Container started successfully"
            
            # Clean up env file
            rm -f /tmp/hiredesk-${{ github.event.inputs.environment }}.env
            
            # Output container info
            echo "üìã Container Information:"
            docker ps --filter "name=${{ env.CONTAINER_NAME }}" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          ENDSSH

          # Set deployment URL
          if [[ "${{ github.event.inputs.environment }}" == "production" ]]; then
            echo "url=https://hiredesk.example.com" >> $GITHUB_OUTPUT
          else
            echo "url=https://staging.hiredesk.example.com" >> $GITHUB_OUTPUT
          fi

      - name: Wait for container to be healthy
        if: github.event.inputs.run_health_checks == 'true'
        run: |
          echo "üè• Waiting for container health checks..."

          ssh -o StrictHostKeyChecking=no ${{ secrets.DEPLOYMENT_USER }}@${{ secrets.DEPLOYMENT_HOST }} << 'ENDSSH'
            set -e
            
            MAX_WAIT=120  # 2 minutes
            ELAPSED=0
            INTERVAL=5
            
            while [ $ELAPSED -lt $MAX_WAIT ]; do
              HEALTH_STATUS=$(docker inspect --format='{{.State.Health.Status}}' ${{ env.CONTAINER_NAME }} 2>/dev/null || echo "unknown")
              
              echo "Health status: $HEALTH_STATUS (${ELAPSED}s elapsed)"
              
              if [ "$HEALTH_STATUS" = "healthy" ]; then
                echo "‚úÖ Container is healthy!"
                exit 0
              elif [ "$HEALTH_STATUS" = "unhealthy" ]; then
                echo "‚ùå Container is unhealthy!"
                docker logs --tail 50 ${{ env.CONTAINER_NAME }}
                exit 1
              fi
              
              sleep $INTERVAL
              ELAPSED=$((ELAPSED + INTERVAL))
            done
            
            echo "‚è∞ Health check timeout"
            docker logs --tail 50 ${{ env.CONTAINER_NAME }}
            exit 1
          ENDSSH

      - name: Run smoke tests
        if: github.event.inputs.run_health_checks == 'true'
        run: |
          echo "üß™ Running smoke tests..."

          ssh -o StrictHostKeyChecking=no ${{ secrets.DEPLOYMENT_USER }}@${{ secrets.DEPLOYMENT_HOST }} << 'ENDSSH'
            set -e
            
            # Test HTTP endpoint
            echo "Testing HTTP endpoint..."
            RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:${{ env.HOST_PORT }})
            
            if [ "$RESPONSE" -eq 200 ]; then
              echo "‚úÖ HTTP test passed (Status: $RESPONSE)"
            else
              echo "‚ùå HTTP test failed (Status: $RESPONSE)"
              exit 1
            fi
            
            # Test container logs for errors
            echo "Checking container logs..."
            if docker logs ${{ env.CONTAINER_NAME }} 2>&1 | grep -i "error" | grep -v "ErrorBoundary"; then
              echo "‚ö†Ô∏è  Errors found in logs"
            else
              echo "‚úÖ No critical errors in logs"
            fi
          ENDSSH

      - name: Cleanup old images
        run: |
          echo "üßπ Cleaning up old Docker images..."

          ssh -o StrictHostKeyChecking=no ${{ secrets.DEPLOYMENT_USER }}@${{ secrets.DEPLOYMENT_HOST }} << 'ENDSSH'
            set -e
            
            # Remove dangling images
            docker image prune -f
            
            # Keep only last 3 versions of HireDesk images
            echo "Keeping last 3 versions of HireDesk images..."
            docker images "${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}" --format "{{.Repository}}:{{.Tag}}" | \
              tail -n +4 | \
              xargs -r docker rmi || true
            
            echo "‚úÖ Cleanup completed"
          ENDSSH

      - name: Generate deployment summary
        run: |
          echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Environment** | \`${{ github.event.inputs.environment }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Image Tag** | \`${{ github.event.inputs.image_tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Deployment ID** | \`${{ needs.validate.outputs.deployment_id }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Triggered By** | @${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Timestamp** | $(date -Iseconds) |" >> $GITHUB_STEP_SUMMARY
          echo "| **Rollback Ready** | ${{ github.event.inputs.enable_rollback }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Health Checks** | ${{ github.event.inputs.run_health_checks }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîó URLs" >> $GITHUB_STEP_SUMMARY
          echo "- **Application URL**: ${{ steps.deployment.outputs.url }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ‚öôÔ∏è Container Info" >> $GITHUB_STEP_SUMMARY
          echo "- **Container Name**: \`${{ env.CONTAINER_NAME }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: \`${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.event.inputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY

  # ==========================================================================
  # Post-Deployment Monitoring
  # ==========================================================================
  monitor:
    name: Post-Deployment Monitoring
    runs-on: ubuntu-latest
    needs: deploy
    if: always()

    steps:
      - name: Check deployment status
        run: |
          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            echo "‚úÖ Deployment completed successfully"
          else
            echo "‚ùå Deployment failed"
            exit 1
          fi

      - name: Notify deployment status
        if: always()
        run: |
          STATUS="${{ needs.deploy.result }}"

          if [[ "$STATUS" == "success" ]]; then
            EMOJI="‚úÖ"
            MESSAGE="Deployment successful"
          else
            EMOJI="‚ùå"
            MESSAGE="Deployment failed"
          fi

          echo "$EMOJI $MESSAGE"
          echo "Environment: ${{ github.event.inputs.environment }}"
          echo "Image: ${{ github.event.inputs.image_tag }}"
          echo "Triggered by: ${{ github.actor }}"

# ============================================================================
# ROLLBACK INSTRUCTIONS
# ============================================================================
# If deployment fails or issues are detected:
#
# Option 1: Quick Rollback (if enable_rollback was true)
#   ssh user@host
#   docker stop hiredesk-ui-production
#   docker rm hiredesk-ui-production
#   docker start hiredesk-ui-production-backup-[timestamp]
#   docker rename hiredesk-ui-production-backup-[timestamp] hiredesk-ui-production
#
# Option 2: Redeploy Previous Version
#   - Trigger this workflow again with previous image tag
#
# Option 3: Manual Intervention
#   - SSH to server
#   - Check logs: docker logs hiredesk-ui-production
#   - Check status: docker ps -a
#   - Investigate and fix
# ============================================================================
